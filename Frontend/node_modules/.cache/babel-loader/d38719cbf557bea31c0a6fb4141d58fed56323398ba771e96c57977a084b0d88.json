{"ast":null,"code":"class AICache {\n  constructor() {\n    this.cache = new Map();\n    this.lastRequestTimes = new Map();\n    this.MIN_REQUEST_INTERVAL = 30000; // 30 seconds minimum between requests\n    this.CACHE_DURATION = 5 * 24 * 60 * 60 * 1000; // 5 days in milliseconds\n  }\n\n  // Generate cache key based on parameters\n  generateCacheKey(endpoint, params = {}) {\n    const sortedParams = Object.keys(params).sort().reduce((result, key) => {\n      result[key] = params[key];\n      return result;\n    }, {});\n    return `${endpoint}:${JSON.stringify(sortedParams)}`;\n  }\n\n  // Check if we should allow a new request (rate limiting)\n  canMakeRequest(cacheKey) {\n    const now = Date.now();\n    const lastRequestTime = this.lastRequestTimes.get(cacheKey);\n    if (!lastRequestTime) {\n      return true;\n    }\n    return now - lastRequestTime >= this.MIN_REQUEST_INTERVAL;\n  }\n\n  // Get cached data if it exists and hasn't expired\n  getCachedData(cacheKey) {\n    const cachedItem = this.cache.get(cacheKey);\n    if (!cachedItem) {\n      return null;\n    }\n    const now = Date.now();\n    const isExpired = now - cachedItem.timestamp > this.CACHE_DURATION;\n    if (isExpired) {\n      this.cache.delete(cacheKey);\n      this.lastRequestTimes.delete(cacheKey);\n      return null;\n    }\n    return cachedItem.data;\n  }\n\n  // Cache data with timestamp\n  setCachedData(cacheKey, data) {\n    this.cache.set(cacheKey, {\n      data,\n      timestamp: Date.now()\n    });\n    this.lastRequestTimes.set(cacheKey, Date.now());\n  }\n\n  // Clear all expired cache entries\n  clearExpiredCache() {\n    const now = Date.now();\n    for (const [key, item] of this.cache.entries()) {\n      if (now - item.timestamp > this.CACHE_DURATION) {\n        this.cache.delete(key);\n        this.lastRequestTimes.delete(key);\n      }\n    }\n  }\n\n  // Force refresh cache for a specific key\n  forceRefreshCache(cacheKey) {\n    this.cache.delete(cacheKey);\n    this.lastRequestTimes.delete(cacheKey);\n  }\n\n  // Get cache info for debugging\n  getCacheInfo() {\n    return {\n      cacheSize: this.cache.size,\n      entries: Array.from(this.cache.keys()),\n      lastRequestTimes: Object.fromEntries(this.lastRequestTimes)\n    };\n  }\n\n  // Check if cache entry is fresh (less than 1 day old)\n  isCacheFresh(cacheKey) {\n    const cachedItem = this.cache.get(cacheKey);\n    if (!cachedItem) return false;\n    const now = Date.now();\n    const oneDayInMs = 24 * 60 * 60 * 1000;\n    return now - cachedItem.timestamp < oneDayInMs;\n  }\n\n  // Get time until cache expires\n  getTimeUntilExpiry(cacheKey) {\n    const cachedItem = this.cache.get(cacheKey);\n    if (!cachedItem) return 0;\n    const now = Date.now();\n    const expiryTime = cachedItem.timestamp + this.CACHE_DURATION;\n    return Math.max(0, expiryTime - now);\n  }\n}\n\n// Create singleton instance\nconst aiCache = new AICache();\n\n// AI API service with caching and rate limiting\nexport class AIService {\n  static async fetchWithCache(endpoint, params = {}, options = {}) {\n    const cacheKey = aiCache.generateCacheKey(endpoint, params);\n\n    // Check if we have fresh cached data\n    const cachedData = aiCache.getCachedData(cacheKey);\n    if (cachedData && !options.forceRefresh) {\n      console.log(`[AI Cache] Using cached data for ${endpoint}`);\n      return {\n        data: cachedData,\n        fromCache: true,\n        cacheAge: Date.now() - aiCache.cache.get(cacheKey).timestamp\n      };\n    }\n\n    // Check rate limiting\n    if (!aiCache.canMakeRequest(cacheKey) && !options.forceRefresh) {\n      const lastRequestTime = aiCache.lastRequestTimes.get(cacheKey);\n      const timeUntilNext = aiCache.MIN_REQUEST_INTERVAL - (Date.now() - lastRequestTime);\n      throw new Error(`Rate limited. Please wait ${Math.ceil(timeUntilNext / 1000)} seconds before making another request.`);\n    }\n    try {\n      // Helper function to get auth headers\n      const getAuthHeaders = () => {\n        const token = localStorage.getItem('token');\n        return {\n          'Content-Type': 'application/json',\n          ...(token && {\n            'Authorization': `Bearer ${token}`\n          }),\n          ...options.headers\n        };\n      };\n\n      // Make API request\n      const url = `${process.env.REACT_APP_API_URL || 'http://localhost:8000'}${endpoint}`;\n      const response = await fetch(url, {\n        method: options.method || 'GET',\n        headers: getAuthHeaders(),\n        body: params && Object.keys(params).length > 0 ? JSON.stringify(params) : undefined,\n        ...options\n      });\n      if (!response.ok) {\n        throw new Error(`API request failed: ${response.status} ${response.statusText}`);\n      }\n      const data = await response.json();\n\n      // Cache the response\n      aiCache.setCachedData(cacheKey, data);\n      console.log(`[AI Cache] Cached new data for ${endpoint}`);\n      return {\n        data,\n        fromCache: false,\n        cached: true\n      };\n    } catch (error) {\n      console.error(`[AI Service] Error fetching ${endpoint}:`, error);\n      throw error;\n    }\n  }\n\n  // Insights API with caching\n  static async getInsights(forceRefresh = false) {\n    return this.fetchWithCache('/ai-coaching/workout-analysis', {}, {\n      forceRefresh,\n      method: 'GET'\n    });\n  }\n\n  // AI Coaching chat with rate limiting\n  static async sendChatMessage(request, forceRefresh = false) {\n    // Ensure request matches backend AICoachingRequest schema\n    const requestBody = {\n      message: request.message || request,\n      conversation_history: request.conversation_history || [],\n      user_data: request.user_data || null\n    };\n    return this.fetchWithCache('/ai-coaching', requestBody, {\n      forceRefresh,\n      method: 'POST'\n    });\n  }\n\n  // Exercise suggestions with caching\n  static async getExerciseSuggestions(muscleGroup, currentExercise, forceRefresh = false) {\n    return this.fetchWithCache('/ai-coaching/exercise-suggestions', {\n      muscle_group: muscleGroup,\n      current_exercise: currentExercise\n    }, {\n      forceRefresh,\n      method: 'POST'\n    });\n  }\n\n  // Get cache status\n  static getCacheStatus() {\n    return aiCache.getCacheInfo();\n  }\n\n  // Clear specific cache\n  static clearCache(endpoint, params = {}) {\n    const cacheKey = aiCache.generateCacheKey(endpoint, params);\n    aiCache.forceRefreshCache(cacheKey);\n  }\n\n  // Clear all cache\n  static clearAllCache() {\n    aiCache.cache.clear();\n    aiCache.lastRequestTimes.clear();\n  }\n\n  // Clean expired cache entries\n  static cleanExpiredCache() {\n    aiCache.clearExpiredCache();\n  }\n}\n\n// Automatically clean expired cache every hour\nsetInterval(() => {\n  AIService.cleanExpiredCache();\n  console.log('[AI Cache] Cleaned expired cache entries');\n}, 60 * 60 * 1000); // 1 hour\n\nexport default AIService;","map":{"version":3,"names":["AICache","constructor","cache","Map","lastRequestTimes","MIN_REQUEST_INTERVAL","CACHE_DURATION","generateCacheKey","endpoint","params","sortedParams","Object","keys","sort","reduce","result","key","JSON","stringify","canMakeRequest","cacheKey","now","Date","lastRequestTime","get","getCachedData","cachedItem","isExpired","timestamp","delete","data","setCachedData","set","clearExpiredCache","item","entries","forceRefreshCache","getCacheInfo","cacheSize","size","Array","from","fromEntries","isCacheFresh","oneDayInMs","getTimeUntilExpiry","expiryTime","Math","max","aiCache","AIService","fetchWithCache","options","cachedData","forceRefresh","console","log","fromCache","cacheAge","timeUntilNext","Error","ceil","getAuthHeaders","token","localStorage","getItem","headers","url","process","env","REACT_APP_API_URL","response","fetch","method","body","length","undefined","ok","status","statusText","json","cached","error","getInsights","sendChatMessage","request","requestBody","message","conversation_history","user_data","getExerciseSuggestions","muscleGroup","currentExercise","muscle_group","current_exercise","getCacheStatus","clearCache","clearAllCache","clear","cleanExpiredCache","setInterval"],"sources":["C:/Users/kidus/OneDrive/Documentos/Summer2025/fitness-tracker-frontend/Frontend/src/services/aiCacheService.js"],"sourcesContent":["class AICache {\r\n    constructor() {\r\n        this.cache = new Map();\r\n        this.lastRequestTimes = new Map();\r\n        this.MIN_REQUEST_INTERVAL = 30000; // 30 seconds minimum between requests\r\n        this.CACHE_DURATION = 5 * 24 * 60 * 60 * 1000; // 5 days in milliseconds\r\n    }\r\n\r\n    // Generate cache key based on parameters\r\n    generateCacheKey(endpoint, params = {}) {\r\n        const sortedParams = Object.keys(params).sort().reduce((result, key) => {\r\n            result[key] = params[key];\r\n            return result;\r\n        }, {});\r\n        return `${endpoint}:${JSON.stringify(sortedParams)}`;\r\n    }\r\n\r\n    // Check if we should allow a new request (rate limiting)\r\n    canMakeRequest(cacheKey) {\r\n        const now = Date.now();\r\n        const lastRequestTime = this.lastRequestTimes.get(cacheKey);\r\n        \r\n        if (!lastRequestTime) {\r\n            return true;\r\n        }\r\n        \r\n        return (now - lastRequestTime) >= this.MIN_REQUEST_INTERVAL;\r\n    }\r\n\r\n    // Get cached data if it exists and hasn't expired\r\n    getCachedData(cacheKey) {\r\n        const cachedItem = this.cache.get(cacheKey);\r\n        \r\n        if (!cachedItem) {\r\n            return null;\r\n        }\r\n        \r\n        const now = Date.now();\r\n        const isExpired = (now - cachedItem.timestamp) > this.CACHE_DURATION;\r\n        \r\n        if (isExpired) {\r\n            this.cache.delete(cacheKey);\r\n            this.lastRequestTimes.delete(cacheKey);\r\n            return null;\r\n        }\r\n        \r\n        return cachedItem.data;\r\n    }\r\n\r\n    // Cache data with timestamp\r\n    setCachedData(cacheKey, data) {\r\n        this.cache.set(cacheKey, {\r\n            data,\r\n            timestamp: Date.now()\r\n        });\r\n        this.lastRequestTimes.set(cacheKey, Date.now());\r\n    }\r\n\r\n    // Clear all expired cache entries\r\n    clearExpiredCache() {\r\n        const now = Date.now();\r\n        for (const [key, item] of this.cache.entries()) {\r\n            if ((now - item.timestamp) > this.CACHE_DURATION) {\r\n                this.cache.delete(key);\r\n                this.lastRequestTimes.delete(key);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Force refresh cache for a specific key\r\n    forceRefreshCache(cacheKey) {\r\n        this.cache.delete(cacheKey);\r\n        this.lastRequestTimes.delete(cacheKey);\r\n    }\r\n\r\n    // Get cache info for debugging\r\n    getCacheInfo() {\r\n        return {\r\n            cacheSize: this.cache.size,\r\n            entries: Array.from(this.cache.keys()),\r\n            lastRequestTimes: Object.fromEntries(this.lastRequestTimes)\r\n        };\r\n    }\r\n\r\n    // Check if cache entry is fresh (less than 1 day old)\r\n    isCacheFresh(cacheKey) {\r\n        const cachedItem = this.cache.get(cacheKey);\r\n        if (!cachedItem) return false;\r\n        \r\n        const now = Date.now();\r\n        const oneDayInMs = 24 * 60 * 60 * 1000;\r\n        return (now - cachedItem.timestamp) < oneDayInMs;\r\n    }\r\n\r\n    // Get time until cache expires\r\n    getTimeUntilExpiry(cacheKey) {\r\n        const cachedItem = this.cache.get(cacheKey);\r\n        if (!cachedItem) return 0;\r\n        \r\n        const now = Date.now();\r\n        const expiryTime = cachedItem.timestamp + this.CACHE_DURATION;\r\n        return Math.max(0, expiryTime - now);\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst aiCache = new AICache();\r\n\r\n// AI API service with caching and rate limiting\r\nexport class AIService {\r\n    static async fetchWithCache(endpoint, params = {}, options = {}) {\r\n        const cacheKey = aiCache.generateCacheKey(endpoint, params);\r\n        \r\n        // Check if we have fresh cached data\r\n        const cachedData = aiCache.getCachedData(cacheKey);\r\n        if (cachedData && !options.forceRefresh) {\r\n            console.log(`[AI Cache] Using cached data for ${endpoint}`);\r\n            return {\r\n                data: cachedData,\r\n                fromCache: true,\r\n                cacheAge: Date.now() - aiCache.cache.get(cacheKey).timestamp\r\n            };\r\n        }\r\n\r\n        // Check rate limiting\r\n        if (!aiCache.canMakeRequest(cacheKey) && !options.forceRefresh) {\r\n            const lastRequestTime = aiCache.lastRequestTimes.get(cacheKey);\r\n            const timeUntilNext = aiCache.MIN_REQUEST_INTERVAL - (Date.now() - lastRequestTime);\r\n            throw new Error(`Rate limited. Please wait ${Math.ceil(timeUntilNext / 1000)} seconds before making another request.`);\r\n        }\r\n\r\n        try {\r\n            // Helper function to get auth headers\r\n            const getAuthHeaders = () => {\r\n                const token = localStorage.getItem('token');\r\n                return {\r\n                    'Content-Type': 'application/json',\r\n                    ...(token && { 'Authorization': `Bearer ${token}` }),\r\n                    ...options.headers\r\n                };\r\n            };\r\n\r\n            // Make API request\r\n            const url = `${process.env.REACT_APP_API_URL || 'http://localhost:8000'}${endpoint}`;\r\n            const response = await fetch(url, {\r\n                method: options.method || 'GET',\r\n                headers: getAuthHeaders(),\r\n                body: params && Object.keys(params).length > 0 ? JSON.stringify(params) : undefined,\r\n                ...options\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`API request failed: ${response.status} ${response.statusText}`);\r\n            }\r\n\r\n            const data = await response.json();\r\n            \r\n            // Cache the response\r\n            aiCache.setCachedData(cacheKey, data);\r\n            console.log(`[AI Cache] Cached new data for ${endpoint}`);\r\n            \r\n            return {\r\n                data,\r\n                fromCache: false,\r\n                cached: true\r\n            };\r\n        } catch (error) {\r\n            console.error(`[AI Service] Error fetching ${endpoint}:`, error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Insights API with caching\r\n    static async getInsights(forceRefresh = false) {\r\n        return this.fetchWithCache('/ai-coaching/workout-analysis', {}, { \r\n            forceRefresh,\r\n            method: 'GET' \r\n        });\r\n    }\r\n\r\n    // AI Coaching chat with rate limiting\r\n    static async sendChatMessage(request, forceRefresh = false) {\r\n        // Ensure request matches backend AICoachingRequest schema\r\n        const requestBody = {\r\n            message: request.message || request,\r\n            conversation_history: request.conversation_history || [],\r\n            user_data: request.user_data || null\r\n        };\r\n        \r\n        return this.fetchWithCache('/ai-coaching', requestBody, { \r\n            forceRefresh,\r\n            method: 'POST' \r\n        });\r\n    }\r\n\r\n    // Exercise suggestions with caching\r\n    static async getExerciseSuggestions(muscleGroup, currentExercise, forceRefresh = false) {\r\n        return this.fetchWithCache('/ai-coaching/exercise-suggestions', {\r\n            muscle_group: muscleGroup,\r\n            current_exercise: currentExercise\r\n        }, { \r\n            forceRefresh,\r\n            method: 'POST' \r\n        });\r\n    }\r\n\r\n    // Get cache status\r\n    static getCacheStatus() {\r\n        return aiCache.getCacheInfo();\r\n    }\r\n\r\n    // Clear specific cache\r\n    static clearCache(endpoint, params = {}) {\r\n        const cacheKey = aiCache.generateCacheKey(endpoint, params);\r\n        aiCache.forceRefreshCache(cacheKey);\r\n    }\r\n\r\n    // Clear all cache\r\n    static clearAllCache() {\r\n        aiCache.cache.clear();\r\n        aiCache.lastRequestTimes.clear();\r\n    }\r\n\r\n    // Clean expired cache entries\r\n    static cleanExpiredCache() {\r\n        aiCache.clearExpiredCache();\r\n    }\r\n}\r\n\r\n// Automatically clean expired cache every hour\r\nsetInterval(() => {\r\n    AIService.cleanExpiredCache();\r\n    console.log('[AI Cache] Cleaned expired cache entries');\r\n}, 60 * 60 * 1000); // 1 hour\r\n\r\nexport default AIService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}