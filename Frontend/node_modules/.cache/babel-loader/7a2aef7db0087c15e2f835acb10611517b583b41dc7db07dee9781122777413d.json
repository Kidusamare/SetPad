{"ast":null,"code":"class AICache {\n  constructor() {\n    this.cache = new Map();\n    this.lastRequestTimes = new Map();\n    this.MIN_REQUEST_INTERVAL = 30000; // 30 seconds minimum between requests\n    this.CACHE_DURATION = 5 * 24 * 60 * 60 * 1000; // 5 days in milliseconds\n  }\n\n  // Generate cache key based on parameters\n  generateCacheKey(endpoint, params = {}) {\n    const sortedParams = Object.keys(params).sort().reduce((result, key) => {\n      result[key] = params[key];\n      return result;\n    }, {});\n    return `${endpoint}:${JSON.stringify(sortedParams)}`;\n  }\n\n  // Check if we should allow a new request (rate limiting)\n  canMakeRequest(cacheKey) {\n    const now = Date.now();\n    const lastRequestTime = this.lastRequestTimes.get(cacheKey);\n    if (!lastRequestTime) {\n      return true;\n    }\n    return now - lastRequestTime >= this.MIN_REQUEST_INTERVAL;\n  }\n\n  // Get cached data if it exists and hasn't expired\n  getCachedData(cacheKey) {\n    const cachedItem = this.cache.get(cacheKey);\n    if (!cachedItem) {\n      return null;\n    }\n    const now = Date.now();\n    const isExpired = now - cachedItem.timestamp > this.CACHE_DURATION;\n    if (isExpired) {\n      this.cache.delete(cacheKey);\n      this.lastRequestTimes.delete(cacheKey);\n      return null;\n    }\n    return cachedItem.data;\n  }\n\n  // Cache data with timestamp\n  setCachedData(cacheKey, data) {\n    this.cache.set(cacheKey, {\n      data,\n      timestamp: Date.now()\n    });\n    this.lastRequestTimes.set(cacheKey, Date.now());\n  }\n\n  // Clear all expired cache entries\n  clearExpiredCache() {\n    const now = Date.now();\n    for (const [key, item] of this.cache.entries()) {\n      if (now - item.timestamp > this.CACHE_DURATION) {\n        this.cache.delete(key);\n        this.lastRequestTimes.delete(key);\n      }\n    }\n  }\n\n  // Force refresh cache for a specific key\n  forceRefreshCache(cacheKey) {\n    this.cache.delete(cacheKey);\n    this.lastRequestTimes.delete(cacheKey);\n  }\n\n  // Get cache info for debugging\n  getCacheInfo() {\n    return {\n      cacheSize: this.cache.size,\n      entries: Array.from(this.cache.keys()),\n      lastRequestTimes: Object.fromEntries(this.lastRequestTimes)\n    };\n  }\n\n  // Check if cache entry is fresh (less than 1 day old)\n  isCacheFresh(cacheKey) {\n    const cachedItem = this.cache.get(cacheKey);\n    if (!cachedItem) return false;\n    const now = Date.now();\n    const oneDayInMs = 24 * 60 * 60 * 1000;\n    return now - cachedItem.timestamp < oneDayInMs;\n  }\n\n  // Get time until cache expires\n  getTimeUntilExpiry(cacheKey) {\n    const cachedItem = this.cache.get(cacheKey);\n    if (!cachedItem) return 0;\n    const now = Date.now();\n    const expiryTime = cachedItem.timestamp + this.CACHE_DURATION;\n    return Math.max(0, expiryTime - now);\n  }\n}\n\n// Create singleton instance\nconst aiCache = new AICache();\n\n// AI API service with caching and rate limiting\nexport class AIService {\n  static async fetchWithCache(endpoint, params = {}, options = {}) {\n    const cacheKey = aiCache.generateCacheKey(endpoint, params);\n\n    // Check if we have fresh cached data\n    const cachedData = aiCache.getCachedData(cacheKey);\n    if (cachedData && !options.forceRefresh) {\n      console.log(`[AI Cache] Using cached data for ${endpoint}`);\n      return {\n        data: cachedData,\n        fromCache: true,\n        cacheAge: Date.now() - aiCache.cache.get(cacheKey).timestamp\n      };\n    }\n\n    // Check rate limiting\n    if (!aiCache.canMakeRequest(cacheKey) && !options.forceRefresh) {\n      const lastRequestTime = aiCache.lastRequestTimes.get(cacheKey);\n      const timeUntilNext = aiCache.MIN_REQUEST_INTERVAL - (Date.now() - lastRequestTime);\n      throw new Error(`Rate limited. Please wait ${Math.ceil(timeUntilNext / 1000)} seconds before making another request.`);\n    }\n    try {\n      // Make API request\n      const url = `${process.env.REACT_APP_API_URL || 'http://localhost:8000'}${endpoint}`;\n      const response = await fetch(url, {\n        method: options.method || 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          ...options.headers\n        },\n        body: params && Object.keys(params).length > 0 ? JSON.stringify(params) : undefined,\n        ...options\n      });\n      if (!response.ok) {\n        throw new Error(`API request failed: ${response.status} ${response.statusText}`);\n      }\n      const data = await response.json();\n\n      // Cache the response\n      aiCache.setCachedData(cacheKey, data);\n      console.log(`[AI Cache] Cached new data for ${endpoint}`);\n      return {\n        data,\n        fromCache: false,\n        cached: true\n      };\n    } catch (error) {\n      console.error(`[AI Service] Error fetching ${endpoint}:`, error);\n      throw error;\n    }\n  }\n\n  // Insights API with caching\n  static async getInsights(forceRefresh = false) {\n    return this.fetchWithCache('/ai-coaching/workout-analysis', {}, {\n      forceRefresh,\n      method: 'GET'\n    });\n  }\n\n  // AI Coaching chat with rate limiting\n  static async sendChatMessage(request, forceRefresh = false) {\n    // Ensure request matches backend AICoachingRequest schema\n    const requestBody = {\n      message: request.message || request,\n      conversation_history: request.conversation_history || [],\n      user_data: request.user_data || null\n    };\n    return this.fetchWithCache('/ai-coaching', requestBody, {\n      forceRefresh,\n      method: 'POST'\n    });\n  }\n\n  // Exercise suggestions with caching\n  static async getExerciseSuggestions(muscleGroup, currentExercise, forceRefresh = false) {\n    return this.fetchWithCache('/ai-coaching/exercise-suggestions', {\n      muscle_group: muscleGroup,\n      current_exercise: currentExercise\n    }, {\n      forceRefresh,\n      method: 'POST'\n    });\n  }\n\n  // Get cache status\n  static getCacheStatus() {\n    return aiCache.getCacheInfo();\n  }\n\n  // Clear specific cache\n  static clearCache(endpoint, params = {}) {\n    const cacheKey = aiCache.generateCacheKey(endpoint, params);\n    aiCache.forceRefreshCache(cacheKey);\n  }\n\n  // Clear all cache\n  static clearAllCache() {\n    aiCache.cache.clear();\n    aiCache.lastRequestTimes.clear();\n  }\n\n  // Clean expired cache entries\n  static cleanExpiredCache() {\n    aiCache.clearExpiredCache();\n  }\n}\n\n// Automatically clean expired cache every hour\nsetInterval(() => {\n  AIService.cleanExpiredCache();\n  console.log('[AI Cache] Cleaned expired cache entries');\n}, 60 * 60 * 1000); // 1 hour\n\nexport default AIService;","map":{"version":3,"names":["AICache","constructor","cache","Map","lastRequestTimes","MIN_REQUEST_INTERVAL","CACHE_DURATION","generateCacheKey","endpoint","params","sortedParams","Object","keys","sort","reduce","result","key","JSON","stringify","canMakeRequest","cacheKey","now","Date","lastRequestTime","get","getCachedData","cachedItem","isExpired","timestamp","delete","data","setCachedData","set","clearExpiredCache","item","entries","forceRefreshCache","getCacheInfo","cacheSize","size","Array","from","fromEntries","isCacheFresh","oneDayInMs","getTimeUntilExpiry","expiryTime","Math","max","aiCache","AIService","fetchWithCache","options","cachedData","forceRefresh","console","log","fromCache","cacheAge","timeUntilNext","Error","ceil","url","process","env","REACT_APP_API_URL","response","fetch","method","headers","body","length","undefined","ok","status","statusText","json","cached","error","getInsights","sendChatMessage","request","requestBody","message","conversation_history","user_data","getExerciseSuggestions","muscleGroup","currentExercise","muscle_group","current_exercise","getCacheStatus","clearCache","clearAllCache","clear","cleanExpiredCache","setInterval"],"sources":["C:/Users/kidus/OneDrive/Documentos/Summer2025/fitness-tracker-frontend/Frontend/src/services/aiCacheService.js"],"sourcesContent":["class AICache {\n    constructor() {\n        this.cache = new Map();\n        this.lastRequestTimes = new Map();\n        this.MIN_REQUEST_INTERVAL = 30000; // 30 seconds minimum between requests\n        this.CACHE_DURATION = 5 * 24 * 60 * 60 * 1000; // 5 days in milliseconds\n    }\n\n    // Generate cache key based on parameters\n    generateCacheKey(endpoint, params = {}) {\n        const sortedParams = Object.keys(params).sort().reduce((result, key) => {\n            result[key] = params[key];\n            return result;\n        }, {});\n        return `${endpoint}:${JSON.stringify(sortedParams)}`;\n    }\n\n    // Check if we should allow a new request (rate limiting)\n    canMakeRequest(cacheKey) {\n        const now = Date.now();\n        const lastRequestTime = this.lastRequestTimes.get(cacheKey);\n        \n        if (!lastRequestTime) {\n            return true;\n        }\n        \n        return (now - lastRequestTime) >= this.MIN_REQUEST_INTERVAL;\n    }\n\n    // Get cached data if it exists and hasn't expired\n    getCachedData(cacheKey) {\n        const cachedItem = this.cache.get(cacheKey);\n        \n        if (!cachedItem) {\n            return null;\n        }\n        \n        const now = Date.now();\n        const isExpired = (now - cachedItem.timestamp) > this.CACHE_DURATION;\n        \n        if (isExpired) {\n            this.cache.delete(cacheKey);\n            this.lastRequestTimes.delete(cacheKey);\n            return null;\n        }\n        \n        return cachedItem.data;\n    }\n\n    // Cache data with timestamp\n    setCachedData(cacheKey, data) {\n        this.cache.set(cacheKey, {\n            data,\n            timestamp: Date.now()\n        });\n        this.lastRequestTimes.set(cacheKey, Date.now());\n    }\n\n    // Clear all expired cache entries\n    clearExpiredCache() {\n        const now = Date.now();\n        for (const [key, item] of this.cache.entries()) {\n            if ((now - item.timestamp) > this.CACHE_DURATION) {\n                this.cache.delete(key);\n                this.lastRequestTimes.delete(key);\n            }\n        }\n    }\n\n    // Force refresh cache for a specific key\n    forceRefreshCache(cacheKey) {\n        this.cache.delete(cacheKey);\n        this.lastRequestTimes.delete(cacheKey);\n    }\n\n    // Get cache info for debugging\n    getCacheInfo() {\n        return {\n            cacheSize: this.cache.size,\n            entries: Array.from(this.cache.keys()),\n            lastRequestTimes: Object.fromEntries(this.lastRequestTimes)\n        };\n    }\n\n    // Check if cache entry is fresh (less than 1 day old)\n    isCacheFresh(cacheKey) {\n        const cachedItem = this.cache.get(cacheKey);\n        if (!cachedItem) return false;\n        \n        const now = Date.now();\n        const oneDayInMs = 24 * 60 * 60 * 1000;\n        return (now - cachedItem.timestamp) < oneDayInMs;\n    }\n\n    // Get time until cache expires\n    getTimeUntilExpiry(cacheKey) {\n        const cachedItem = this.cache.get(cacheKey);\n        if (!cachedItem) return 0;\n        \n        const now = Date.now();\n        const expiryTime = cachedItem.timestamp + this.CACHE_DURATION;\n        return Math.max(0, expiryTime - now);\n    }\n}\n\n// Create singleton instance\nconst aiCache = new AICache();\n\n// AI API service with caching and rate limiting\nexport class AIService {\n    static async fetchWithCache(endpoint, params = {}, options = {}) {\n        const cacheKey = aiCache.generateCacheKey(endpoint, params);\n        \n        // Check if we have fresh cached data\n        const cachedData = aiCache.getCachedData(cacheKey);\n        if (cachedData && !options.forceRefresh) {\n            console.log(`[AI Cache] Using cached data for ${endpoint}`);\n            return {\n                data: cachedData,\n                fromCache: true,\n                cacheAge: Date.now() - aiCache.cache.get(cacheKey).timestamp\n            };\n        }\n\n        // Check rate limiting\n        if (!aiCache.canMakeRequest(cacheKey) && !options.forceRefresh) {\n            const lastRequestTime = aiCache.lastRequestTimes.get(cacheKey);\n            const timeUntilNext = aiCache.MIN_REQUEST_INTERVAL - (Date.now() - lastRequestTime);\n            throw new Error(`Rate limited. Please wait ${Math.ceil(timeUntilNext / 1000)} seconds before making another request.`);\n        }\n\n        try {\n            // Make API request\n            const url = `${process.env.REACT_APP_API_URL || 'http://localhost:8000'}${endpoint}`;\n            const response = await fetch(url, {\n                method: options.method || 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    ...options.headers\n                },\n                body: params && Object.keys(params).length > 0 ? JSON.stringify(params) : undefined,\n                ...options\n            });\n\n            if (!response.ok) {\n                throw new Error(`API request failed: ${response.status} ${response.statusText}`);\n            }\n\n            const data = await response.json();\n            \n            // Cache the response\n            aiCache.setCachedData(cacheKey, data);\n            console.log(`[AI Cache] Cached new data for ${endpoint}`);\n            \n            return {\n                data,\n                fromCache: false,\n                cached: true\n            };\n        } catch (error) {\n            console.error(`[AI Service] Error fetching ${endpoint}:`, error);\n            throw error;\n        }\n    }\n\n    // Insights API with caching\n    static async getInsights(forceRefresh = false) {\n        return this.fetchWithCache('/ai-coaching/workout-analysis', {}, { \n            forceRefresh,\n            method: 'GET' \n        });\n    }\n\n    // AI Coaching chat with rate limiting\n    static async sendChatMessage(request, forceRefresh = false) {\n        // Ensure request matches backend AICoachingRequest schema\n        const requestBody = {\n            message: request.message || request,\n            conversation_history: request.conversation_history || [],\n            user_data: request.user_data || null\n        };\n        \n        return this.fetchWithCache('/ai-coaching', requestBody, { \n            forceRefresh,\n            method: 'POST' \n        });\n    }\n\n    // Exercise suggestions with caching\n    static async getExerciseSuggestions(muscleGroup, currentExercise, forceRefresh = false) {\n        return this.fetchWithCache('/ai-coaching/exercise-suggestions', {\n            muscle_group: muscleGroup,\n            current_exercise: currentExercise\n        }, { \n            forceRefresh,\n            method: 'POST' \n        });\n    }\n\n    // Get cache status\n    static getCacheStatus() {\n        return aiCache.getCacheInfo();\n    }\n\n    // Clear specific cache\n    static clearCache(endpoint, params = {}) {\n        const cacheKey = aiCache.generateCacheKey(endpoint, params);\n        aiCache.forceRefreshCache(cacheKey);\n    }\n\n    // Clear all cache\n    static clearAllCache() {\n        aiCache.cache.clear();\n        aiCache.lastRequestTimes.clear();\n    }\n\n    // Clean expired cache entries\n    static cleanExpiredCache() {\n        aiCache.clearExpiredCache();\n    }\n}\n\n// Automatically clean expired cache every hour\nsetInterval(() => {\n    AIService.cleanExpiredCache();\n    console.log('[AI Cache] Cleaned expired cache entries');\n}, 60 * 60 * 1000); // 1 hour\n\nexport default AIService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}