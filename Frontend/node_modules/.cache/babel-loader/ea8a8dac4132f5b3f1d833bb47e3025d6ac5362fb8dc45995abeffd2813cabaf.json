{"ast":null,"code":"/**\n * Offline Storage Service\n * Provides comprehensive offline support with automatic sync when online\n */\n\nclass OfflineStorage {\n  constructor() {\n    this.dbName = 'SetPadOfflineDB';\n    this.version = 1;\n    this.db = null;\n    this.isOnline = navigator.onLine;\n    this.syncQueue = [];\n    this.initializeDB();\n    this.setupOnlineDetection();\n  }\n  async initializeDB() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve(this.db);\n      };\n      request.onupgradeneeded = event => {\n        const db = event.target.result;\n\n        // Workout logs store\n        if (!db.objectStoreNames.contains('workoutLogs')) {\n          const workoutStore = db.createObjectStore('workoutLogs', {\n            keyPath: 'id'\n          });\n          workoutStore.createIndex('date', 'date', {\n            unique: false\n          });\n          workoutStore.createIndex('tableName', 'tableName', {\n            unique: false\n          });\n        }\n\n        // Sync queue store\n        if (!db.objectStoreNames.contains('syncQueue')) {\n          db.createObjectStore('syncQueue', {\n            keyPath: 'id',\n            autoIncrement: true\n          });\n        }\n\n        // User preferences store\n        if (!db.objectStoreNames.contains('preferences')) {\n          db.createObjectStore('preferences', {\n            keyPath: 'key'\n          });\n        }\n\n        // Exercise history for smart defaults\n        if (!db.objectStoreNames.contains('exerciseHistory')) {\n          const exerciseStore = db.createObjectStore('exerciseHistory', {\n            keyPath: 'id',\n            autoIncrement: true\n          });\n          exerciseStore.createIndex('exercise', 'exercise', {\n            unique: false\n          });\n          exerciseStore.createIndex('muscleGroup', 'muscleGroup', {\n            unique: false\n          });\n        }\n      };\n    });\n  }\n  setupOnlineDetection() {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.syncPendingChanges();\n      console.log('[Offline Storage] Back online, syncing changes...');\n    });\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      console.log('[Offline Storage] Gone offline, storing changes locally');\n    });\n  }\n\n  // Generic database operations\n  async performDBOperation(storeName, operation, data = null) {\n    if (!this.db) await this.initializeDB();\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([storeName], 'readwrite');\n      const store = transaction.objectStore(storeName);\n      let request;\n      switch (operation) {\n        case 'get':\n          request = store.get(data);\n          break;\n        case 'getAll':\n          request = store.getAll();\n          break;\n        case 'put':\n          request = store.put(data);\n          break;\n        case 'delete':\n          request = store.delete(data);\n          break;\n        case 'clear':\n          request = store.clear();\n          break;\n        default:\n          reject(new Error(`Unknown operation: ${operation}`));\n          return;\n      }\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  // Workout log operations\n  async saveWorkoutLog(log) {\n    try {\n      // Always save locally first\n      await this.performDBOperation('workoutLogs', 'put', {\n        ...log,\n        lastModified: new Date().toISOString(),\n        synced: false\n      });\n\n      // If online, try to sync immediately\n      if (this.isOnline) {\n        await this.syncWorkoutLog(log);\n      } else {\n        // Add to sync queue\n        await this.addToSyncQueue('saveWorkoutLog', log);\n      }\n      return true;\n    } catch (error) {\n      console.error('[Offline Storage] Error saving workout log:', error);\n      return false;\n    }\n  }\n  async loadWorkoutLog(id) {\n    try {\n      return await this.performDBOperation('workoutLogs', 'get', id);\n    } catch (error) {\n      console.error('[Offline Storage] Error loading workout log:', error);\n      return null;\n    }\n  }\n  async getAllWorkoutLogs() {\n    try {\n      const logs = await this.performDBOperation('workoutLogs', 'getAll');\n      return logs.sort((a, b) => new Date(b.date) - new Date(a.date));\n    } catch (error) {\n      console.error('[Offline Storage] Error loading workout logs:', error);\n      return [];\n    }\n  }\n  async deleteWorkoutLog(id) {\n    try {\n      await this.performDBOperation('workoutLogs', 'delete', id);\n      if (this.isOnline) {\n        await this.syncDeleteWorkoutLog(id);\n      } else {\n        await this.addToSyncQueue('deleteWorkoutLog', {\n          id\n        });\n      }\n      return true;\n    } catch (error) {\n      console.error('[Offline Storage] Error deleting workout log:', error);\n      return false;\n    }\n  }\n\n  // Sync queue operations\n  async addToSyncQueue(operation, data) {\n    await this.performDBOperation('syncQueue', 'put', {\n      operation,\n      data,\n      timestamp: new Date().toISOString()\n    });\n  }\n  async syncPendingChanges() {\n    if (!this.isOnline) return;\n    try {\n      const syncItems = await this.performDBOperation('syncQueue', 'getAll');\n      for (const item of syncItems) {\n        try {\n          switch (item.operation) {\n            case 'saveWorkoutLog':\n              await this.syncWorkoutLog(item.data);\n              break;\n            case 'deleteWorkoutLog':\n              await this.syncDeleteWorkoutLog(item.data.id);\n              break;\n          }\n\n          // Remove from sync queue after successful sync\n          await this.performDBOperation('syncQueue', 'delete', item.id);\n        } catch (syncError) {\n          console.warn('[Offline Storage] Failed to sync item:', item, syncError);\n          // Keep in queue for next attempt\n        }\n      }\n      console.log(`[Offline Storage] Synced ${syncItems.length} pending changes`);\n    } catch (error) {\n      console.error('[Offline Storage] Error syncing pending changes:', error);\n    }\n  }\n\n  // Actual sync operations (integrate with existing API)\n  async syncWorkoutLog(log) {\n    // This would integrate with your existing TrainingLogManager\n    try {\n      const response = await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:8000'}/tables`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(log)\n      });\n      if (response.ok) {\n        // Mark as synced in local storage\n        await this.performDBOperation('workoutLogs', 'put', {\n          ...log,\n          synced: true,\n          lastSynced: new Date().toISOString()\n        });\n      }\n    } catch (error) {\n      // Network error - keep in local storage unsynced\n      throw error;\n    }\n  }\n  async syncDeleteWorkoutLog(id) {\n    try {\n      await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:8000'}/tables/${id}`, {\n        method: 'DELETE'\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // Exercise history for smart defaults\n  async saveExerciseHistory(exerciseData) {\n    var _exerciseData$sets, _exerciseData$sets$, _exerciseData$sets2, _exerciseData$sets2$;\n    const historyEntry = {\n      exercise: exerciseData.exercise,\n      muscleGroup: exerciseData.muscleGroup,\n      sets: exerciseData.sets,\n      date: exerciseData.date || new Date().toISOString(),\n      weight: ((_exerciseData$sets = exerciseData.sets) === null || _exerciseData$sets === void 0 ? void 0 : (_exerciseData$sets$ = _exerciseData$sets[0]) === null || _exerciseData$sets$ === void 0 ? void 0 : _exerciseData$sets$.weight) || '',\n      reps: ((_exerciseData$sets2 = exerciseData.sets) === null || _exerciseData$sets2 === void 0 ? void 0 : (_exerciseData$sets2$ = _exerciseData$sets2[0]) === null || _exerciseData$sets2$ === void 0 ? void 0 : _exerciseData$sets2$.reps) || ''\n    };\n    await this.performDBOperation('exerciseHistory', 'put', historyEntry);\n  }\n  async getExerciseHistory(exerciseName, limit = 10) {\n    try {\n      const allHistory = await this.performDBOperation('exerciseHistory', 'getAll');\n      return allHistory.filter(entry => {\n        var _entry$exercise;\n        return ((_entry$exercise = entry.exercise) === null || _entry$exercise === void 0 ? void 0 : _entry$exercise.toLowerCase()) === (exerciseName === null || exerciseName === void 0 ? void 0 : exerciseName.toLowerCase());\n      }).sort((a, b) => new Date(b.date) - new Date(a.date)).slice(0, limit);\n    } catch (error) {\n      console.error('[Offline Storage] Error getting exercise history:', error);\n      return [];\n    }\n  }\n\n  // User preferences\n  async savePreference(key, value) {\n    await this.performDBOperation('preferences', 'put', {\n      key,\n      value\n    });\n  }\n  async getPreference(key, defaultValue = null) {\n    try {\n      const result = await this.performDBOperation('preferences', 'get', key);\n      return result ? result.value : defaultValue;\n    } catch (error) {\n      return defaultValue;\n    }\n  }\n\n  // Utility methods\n  async getStorageInfo() {\n    var _workoutLogs$find;\n    const workoutLogs = await this.getAllWorkoutLogs();\n    const syncQueue = await this.performDBOperation('syncQueue', 'getAll');\n    return {\n      isOnline: this.isOnline,\n      totalWorkouts: workoutLogs.length,\n      unsyncedWorkouts: workoutLogs.filter(log => !log.synced).length,\n      pendingSyncItems: syncQueue.length,\n      lastSync: ((_workoutLogs$find = workoutLogs.find(log => log.synced)) === null || _workoutLogs$find === void 0 ? void 0 : _workoutLogs$find.lastSynced) || null\n    };\n  }\n  async clearAllData() {\n    const stores = ['workoutLogs', 'syncQueue', 'preferences', 'exerciseHistory'];\n    for (const store of stores) {\n      await this.performDBOperation(store, 'clear');\n    }\n  }\n}\n\n// Create singleton instance\nconst offlineStorage = new OfflineStorage();\nexport default offlineStorage;","map":{"version":3,"names":["OfflineStorage","constructor","dbName","version","db","isOnline","navigator","onLine","syncQueue","initializeDB","setupOnlineDetection","Promise","resolve","reject","request","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","event","target","objectStoreNames","contains","workoutStore","createObjectStore","keyPath","createIndex","unique","autoIncrement","exerciseStore","window","addEventListener","syncPendingChanges","console","log","performDBOperation","storeName","operation","data","transaction","store","objectStore","get","getAll","put","delete","clear","Error","saveWorkoutLog","lastModified","Date","toISOString","synced","syncWorkoutLog","addToSyncQueue","loadWorkoutLog","id","getAllWorkoutLogs","logs","sort","a","b","date","deleteWorkoutLog","syncDeleteWorkoutLog","timestamp","syncItems","item","syncError","warn","length","response","fetch","process","env","REACT_APP_API_URL","method","headers","body","JSON","stringify","ok","lastSynced","saveExerciseHistory","exerciseData","_exerciseData$sets","_exerciseData$sets$","_exerciseData$sets2","_exerciseData$sets2$","historyEntry","exercise","muscleGroup","sets","weight","reps","getExerciseHistory","exerciseName","limit","allHistory","filter","entry","_entry$exercise","toLowerCase","slice","savePreference","key","value","getPreference","defaultValue","getStorageInfo","_workoutLogs$find","workoutLogs","totalWorkouts","unsyncedWorkouts","pendingSyncItems","lastSync","find","clearAllData","stores","offlineStorage"],"sources":["C:/Users/kidus/OneDrive/Documentos/Summer2025/fitness-tracker-frontend/src/services/offlineStorage.js"],"sourcesContent":["/**\n * Offline Storage Service\n * Provides comprehensive offline support with automatic sync when online\n */\n\nclass OfflineStorage {\n    constructor() {\n        this.dbName = 'SetPadOfflineDB';\n        this.version = 1;\n        this.db = null;\n        this.isOnline = navigator.onLine;\n        this.syncQueue = [];\n        this.initializeDB();\n        this.setupOnlineDetection();\n    }\n\n    async initializeDB() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.version);\n            \n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n            \n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                \n                // Workout logs store\n                if (!db.objectStoreNames.contains('workoutLogs')) {\n                    const workoutStore = db.createObjectStore('workoutLogs', { keyPath: 'id' });\n                    workoutStore.createIndex('date', 'date', { unique: false });\n                    workoutStore.createIndex('tableName', 'tableName', { unique: false });\n                }\n                \n                // Sync queue store\n                if (!db.objectStoreNames.contains('syncQueue')) {\n                    db.createObjectStore('syncQueue', { keyPath: 'id', autoIncrement: true });\n                }\n                \n                // User preferences store\n                if (!db.objectStoreNames.contains('preferences')) {\n                    db.createObjectStore('preferences', { keyPath: 'key' });\n                }\n                \n                // Exercise history for smart defaults\n                if (!db.objectStoreNames.contains('exerciseHistory')) {\n                    const exerciseStore = db.createObjectStore('exerciseHistory', { keyPath: 'id', autoIncrement: true });\n                    exerciseStore.createIndex('exercise', 'exercise', { unique: false });\n                    exerciseStore.createIndex('muscleGroup', 'muscleGroup', { unique: false });\n                }\n            };\n        });\n    }\n\n    setupOnlineDetection() {\n        window.addEventListener('online', () => {\n            this.isOnline = true;\n            this.syncPendingChanges();\n            console.log('[Offline Storage] Back online, syncing changes...');\n        });\n        \n        window.addEventListener('offline', () => {\n            this.isOnline = false;\n            console.log('[Offline Storage] Gone offline, storing changes locally');\n        });\n    }\n\n    // Generic database operations\n    async performDBOperation(storeName, operation, data = null) {\n        if (!this.db) await this.initializeDB();\n        \n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction([storeName], 'readwrite');\n            const store = transaction.objectStore(storeName);\n            let request;\n            \n            switch (operation) {\n                case 'get':\n                    request = store.get(data);\n                    break;\n                case 'getAll':\n                    request = store.getAll();\n                    break;\n                case 'put':\n                    request = store.put(data);\n                    break;\n                case 'delete':\n                    request = store.delete(data);\n                    break;\n                case 'clear':\n                    request = store.clear();\n                    break;\n                default:\n                    reject(new Error(`Unknown operation: ${operation}`));\n                    return;\n            }\n            \n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    // Workout log operations\n    async saveWorkoutLog(log) {\n        try {\n            // Always save locally first\n            await this.performDBOperation('workoutLogs', 'put', {\n                ...log,\n                lastModified: new Date().toISOString(),\n                synced: false\n            });\n            \n            // If online, try to sync immediately\n            if (this.isOnline) {\n                await this.syncWorkoutLog(log);\n            } else {\n                // Add to sync queue\n                await this.addToSyncQueue('saveWorkoutLog', log);\n            }\n            \n            return true;\n        } catch (error) {\n            console.error('[Offline Storage] Error saving workout log:', error);\n            return false;\n        }\n    }\n\n    async loadWorkoutLog(id) {\n        try {\n            return await this.performDBOperation('workoutLogs', 'get', id);\n        } catch (error) {\n            console.error('[Offline Storage] Error loading workout log:', error);\n            return null;\n        }\n    }\n\n    async getAllWorkoutLogs() {\n        try {\n            const logs = await this.performDBOperation('workoutLogs', 'getAll');\n            return logs.sort((a, b) => new Date(b.date) - new Date(a.date));\n        } catch (error) {\n            console.error('[Offline Storage] Error loading workout logs:', error);\n            return [];\n        }\n    }\n\n    async deleteWorkoutLog(id) {\n        try {\n            await this.performDBOperation('workoutLogs', 'delete', id);\n            \n            if (this.isOnline) {\n                await this.syncDeleteWorkoutLog(id);\n            } else {\n                await this.addToSyncQueue('deleteWorkoutLog', { id });\n            }\n            \n            return true;\n        } catch (error) {\n            console.error('[Offline Storage] Error deleting workout log:', error);\n            return false;\n        }\n    }\n\n    // Sync queue operations\n    async addToSyncQueue(operation, data) {\n        await this.performDBOperation('syncQueue', 'put', {\n            operation,\n            data,\n            timestamp: new Date().toISOString()\n        });\n    }\n\n    async syncPendingChanges() {\n        if (!this.isOnline) return;\n        \n        try {\n            const syncItems = await this.performDBOperation('syncQueue', 'getAll');\n            \n            for (const item of syncItems) {\n                try {\n                    switch (item.operation) {\n                        case 'saveWorkoutLog':\n                            await this.syncWorkoutLog(item.data);\n                            break;\n                        case 'deleteWorkoutLog':\n                            await this.syncDeleteWorkoutLog(item.data.id);\n                            break;\n                    }\n                    \n                    // Remove from sync queue after successful sync\n                    await this.performDBOperation('syncQueue', 'delete', item.id);\n                    \n                } catch (syncError) {\n                    console.warn('[Offline Storage] Failed to sync item:', item, syncError);\n                    // Keep in queue for next attempt\n                }\n            }\n            \n            console.log(`[Offline Storage] Synced ${syncItems.length} pending changes`);\n        } catch (error) {\n            console.error('[Offline Storage] Error syncing pending changes:', error);\n        }\n    }\n\n    // Actual sync operations (integrate with existing API)\n    async syncWorkoutLog(log) {\n        // This would integrate with your existing TrainingLogManager\n        try {\n            const response = await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:8000'}/tables`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(log)\n            });\n            \n            if (response.ok) {\n                // Mark as synced in local storage\n                await this.performDBOperation('workoutLogs', 'put', {\n                    ...log,\n                    synced: true,\n                    lastSynced: new Date().toISOString()\n                });\n            }\n        } catch (error) {\n            // Network error - keep in local storage unsynced\n            throw error;\n        }\n    }\n\n    async syncDeleteWorkoutLog(id) {\n        try {\n            await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:8000'}/tables/${id}`, {\n                method: 'DELETE'\n            });\n        } catch (error) {\n            throw error;\n        }\n    }\n\n    // Exercise history for smart defaults\n    async saveExerciseHistory(exerciseData) {\n        const historyEntry = {\n            exercise: exerciseData.exercise,\n            muscleGroup: exerciseData.muscleGroup,\n            sets: exerciseData.sets,\n            date: exerciseData.date || new Date().toISOString(),\n            weight: exerciseData.sets?.[0]?.weight || '',\n            reps: exerciseData.sets?.[0]?.reps || ''\n        };\n        \n        await this.performDBOperation('exerciseHistory', 'put', historyEntry);\n    }\n\n    async getExerciseHistory(exerciseName, limit = 10) {\n        try {\n            const allHistory = await this.performDBOperation('exerciseHistory', 'getAll');\n            return allHistory\n                .filter(entry => entry.exercise?.toLowerCase() === exerciseName?.toLowerCase())\n                .sort((a, b) => new Date(b.date) - new Date(a.date))\n                .slice(0, limit);\n        } catch (error) {\n            console.error('[Offline Storage] Error getting exercise history:', error);\n            return [];\n        }\n    }\n\n    // User preferences\n    async savePreference(key, value) {\n        await this.performDBOperation('preferences', 'put', { key, value });\n    }\n\n    async getPreference(key, defaultValue = null) {\n        try {\n            const result = await this.performDBOperation('preferences', 'get', key);\n            return result ? result.value : defaultValue;\n        } catch (error) {\n            return defaultValue;\n        }\n    }\n\n    // Utility methods\n    async getStorageInfo() {\n        const workoutLogs = await this.getAllWorkoutLogs();\n        const syncQueue = await this.performDBOperation('syncQueue', 'getAll');\n        \n        return {\n            isOnline: this.isOnline,\n            totalWorkouts: workoutLogs.length,\n            unsyncedWorkouts: workoutLogs.filter(log => !log.synced).length,\n            pendingSyncItems: syncQueue.length,\n            lastSync: workoutLogs.find(log => log.synced)?.lastSynced || null\n        };\n    }\n\n    async clearAllData() {\n        const stores = ['workoutLogs', 'syncQueue', 'preferences', 'exerciseHistory'];\n        for (const store of stores) {\n            await this.performDBOperation(store, 'clear');\n        }\n    }\n}\n\n// Create singleton instance\nconst offlineStorage = new OfflineStorage();\n\nexport default offlineStorage;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}